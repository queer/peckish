use std::path::PathBuf;

use color_eyre::Result;

use crate::util::config::Injection;
use crate::util::MemoryFS;

use super::tarball::{TarballArtifact, TarballProducer};
use super::{Artifact, ArtifactProducer};

pub struct ArchArtifact {
    name: String,
    path: PathBuf,
}

#[async_trait::async_trait]
impl Artifact for ArchArtifact {
    fn name(&self) -> &String {
        &self.name
    }

    fn description(&self) -> String {
        "an arch linux package".into()
    }

    async fn extract(&self) -> Result<MemoryFS> {
        TarballArtifact {
            name: format!("{}-tarball-extractor", self.name),
            path: self.path.clone(),
        }
        .extract()
        .await
    }
}

pub struct ArchProducer {
    pub name: String,
    pub path: PathBuf,
    pub injections: Vec<Injection>,
}

#[async_trait::async_trait]
impl ArtifactProducer for ArchProducer {
    type Output = ArchArtifact;

    fn name(&self) -> &String {
        &self.name
    }

    fn injections(&self) -> &[Injection] {
        &self.injections
    }

    async fn produce(&self, previous: &dyn Artifact) -> Result<Self::Output> {
        // TODO: .PKGINFO
        /*
         * # generated by peckish
         * # :^)
         * pkgname = "foo"
         * pkgbase = "foo"
         * pkgver = "1.0.0"
         * pkgdesc = "a foo that bars"
         * url: "https://example.com/foo"
         * builddate = 1234567890 # unix time
         * packager = "unknown"
         * size = 1234567890 # bytes
         * arch = "x86_64"
         * license = "custom"
         * provides = "foo"
         * depend = "bar"
         * depend = "baz"
         * optdepend = "quux"
         */

        TarballProducer {
            name: format!("{}-tarball-producer", self.name),
            path: self.path.clone(),
            injections: vec![], // TODO: Inject .PKGINFO
        }
        .produce(previous)
        .await
        .map(|tarball| ArchArtifact {
            name: self.name.clone(),
            path: tarball.path,
        })
    }
}
