use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};

use color_eyre::Result;

use crate::fs::MemFS;
use crate::util::config::Injection;

use super::tarball::{TarballArtifact, TarballProducer};
use super::{get_artifact_size, Artifact, ArtifactProducer};

/// An Arch Linux package. This is a **non-compressed** tarball file with a
/// `.pkg.tar` extension and a `.PKGINFO` file in the root.
#[derive(Debug, Clone)]
pub struct ArchArtifact {
    /// The name of the artifact. Used for ex. logging.
    pub name: String,
    /// The path to the artifact.
    pub path: PathBuf,
}

#[async_trait::async_trait]
impl Artifact for ArchArtifact {
    fn name(&self) -> &str {
        &self.name
    }

    async fn extract(&self) -> Result<MemFS> {
        TarballArtifact {
            name: format!("{}-tarball-extractor", self.name),
            path: self.path.clone(),
        }
        .extract()
        .await
    }
}

/// An [`ArtifactProducer`] that produces an Arch Linux package. This is a
/// **non-compressed** tarball file with a `.pkg.tar` extension and a
/// `.PKGINFO` file in the root. The `.PKGINFO` file is generated from the
/// `package_*` fields on the struct. The size of the package is calculated
/// from the previous artifact's memfs.
///
/// TODO: Validate architectures
/// TODO: Validate version numbers
/// TODO: Validate package names
#[derive(Debug, Clone)]
pub struct ArchProducer {
    pub name: String,
    pub package_name: String,
    pub package_ver: String,
    pub package_desc: String,
    pub package_author: String,
    pub package_arch: String,
    pub path: PathBuf,
    pub injections: Vec<Injection>,
}

#[async_trait::async_trait]
impl ArtifactProducer for ArchProducer {
    type Output = ArchArtifact;

    fn name(&self) -> &str {
        &self.name
    }

    fn injections(&self) -> &[Injection] {
        &self.injections
    }

    async fn produce(&self, previous: &dyn Artifact) -> Result<Self::Output> {
        let size = get_artifact_size(previous).await?;

        let content = indoc::formatdoc! {r#"
            # generated by peckish
            pkgname = {name}
            pkgbase = {name}
            pkgver = {version}
            pkgdesc = {desc}
            builddate = {time}
            packager = {author}
            size = {size}
            arch = {arch}
            provides = {name}
        "#,
            name = self.package_name,
            time = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs(),
            author = self.package_author,
            size = size,
            desc = self.package_desc,
            version = self.package_ver,
            arch = self.package_arch,
        };

        let mut new_injections = self.injections.clone();
        new_injections.push(Injection::Create {
            path: PathBuf::from(".PKGINFO"),
            content: content.clone().into(),
        });

        if let Some(parent) = self.path.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }

        TarballProducer {
            name: format!("{}-tarball-producer", self.name),
            path: self.path.clone(),
            injections: new_injections,
        }
        .produce(previous)
        .await
        .map(|tarball| ArchArtifact {
            name: self.name.clone(),
            path: tarball.path,
        })
    }
}
